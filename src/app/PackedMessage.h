/*
 * packedmessage.h
 *
 *  Created on: Mar 9, 2014
 *      Author: Adam Kosiorek
 */
#ifndef PACKEDMESSAGE_H
#define PACKEDMESSAGE_H

#include <vector>
#include <memory>
#include <cstdint>

/**
 *  PackedMessage implements simple "packing" of protocol buffers Messages into
 *  a string prepended by a header specifying the message length.
 *  MsgType should be a Message class generated by the protobuf compiler.
 */
template<class MsgType, class BuffType = std::vector<uint8_t>>
class PackedMessage {
public:
	typedef MsgType MessageType;
	typedef BuffType BufferType;
	typedef std::shared_ptr<MsgType> MsgPtr;

public:
	PackedMessage();

	/**
	 *
	 */
	PackedMessage(MsgPtr msg);

	/**
	 *
	 */
	void setMsg(MsgPtr msg);

	/**
	 *
	 */
	MsgPtr getMsg() const;

	/**
	 *  Pack the message into the given data_buffer. The buffer is resized to
	 *  exactly fit the message.
	 *  Return false in case of an error, true if successful.
	 */
	bool pack(BuffType& buf) const;

	/**
	 *  Given a buffer with the first HEADER_SIZE bytes representing the header,
	 *  decode the header and return the message length. Return 0 in case of
	 *  an error.
	 */
	unsigned decodeHeader(const BuffType& buf) const;

	/**
	 *  Unpack and store a message from the given packed buffer.
	 *   Return true if unpacking successful, false otherwise.
	 */
	bool unpack(const BuffType& buf);

	/**
	 *  The header size for packed messages
	 */
	static const unsigned HEADER_SIZE;
private:

	/**
	 *  Encodes the side into a header at the beginning of buf
	 */
	void encodeHeader(BuffType& buf, unsigned size) const;

	MsgPtr msg_;
};

#endif /* PACKEDMESSAGE_H */

