/*
 * packedmessage.h
 *
 *  Created on: Mar 9, 2014
 *      Author: Adam Kosiorek
 */
#ifndef PACKEDMESSAGE_H
#define PACKEDMESSAGE_H

#include <vector>
#include <memory>

typedef std::vector<uint8_t> DataBuffer;

/**
 *  PackedMessage implements simple "packing" of protocol buffers Messages into
 *  a string prepended by a header specifying the message length.
 *  MessageType should be a Message class generated by the protobuf compiler.
 */
template<class MessageType>
class PackedMessage {
public:
	typedef std::shared_ptr<MessageType> MessagePointer;

	PackedMessage() : msg_(std::move(std::shared_ptr<MessageType>(new MessageType()))) {};

	/**
	 *
	 */
	PackedMessage(MessagePointer msg) {
		if(msg == nullptr) throw new std::logic_error("Cannot pack a null message");
		msg_ = std::move(msg);
	};

	/**
	 *
	 */
	void setMsg(MessagePointer msg) {
		if(msg == nullptr) throw new std::logic_error("Cannot pack a null message");
		msg_ = std::move(msg);
	}

	/**
	 *
	 */
	MessagePointer getMsg() {
		return msg_;
	}

	/**
	 *  Pack the message into the given data_buffer. The buffer is resized to
	 *  exactly fit the message.
	 *  Return false in case of an error, true if successful.
	 */
	bool pack(DataBuffer& buf) const {
			if (!msg_->IsInitialized())
				throw new std::logic_error("Cannot pack a null message");

			unsigned msg_size = msg_->ByteSize();
			buf.resize(HEADER_SIZE + msg_size);
			encodeHeader(buf, msg_size);
			return msg_->SerializeToArray(&buf[HEADER_SIZE], msg_size);
		}

	/**
	 *  Given a buffer with the first HEADER_SIZE bytes representing the header,
	 *  decode the header and return the message length. Return 0 in case of
	 *  an error.
	 */
	unsigned decodeHeader(const DataBuffer& buf) const {
			if (buf.size() < HEADER_SIZE)
				throw new std::logic_error("Buffer's size should be >= 4");

			unsigned msg_size = 0;
			for (unsigned i = 0; i < HEADER_SIZE; ++i)
				msg_size = msg_size * 256 + (static_cast<unsigned>(buf[i]) & 0xFF);
			return msg_size;
		}

	/**
	 *  Unpack and store a message from the given packed buffer.
	 *   Return true if unpacking successful, false otherwise.
	 */
	bool unpack(const DataBuffer& buf) {
			return msg_->ParseFromArray(&buf[HEADER_SIZE],
					buf.size() - HEADER_SIZE);
		}

	/**
	 *  The header size for packed messages
	 */
	const unsigned HEADER_SIZE = 4;
private:

	/**
	 *  Encodes the side into a header at the beginning of buf
	 */
	void encodeHeader(DataBuffer& buf, unsigned size) const {
			assert(buf.size() >= HEADER_SIZE);
			buf[0] = static_cast<uint8_t>((size >> 24) & 0xFF);
			buf[1] = static_cast<uint8_t>((size >> 16) & 0xFF);
			buf[2] = static_cast<uint8_t>((size >> 8) & 0xFF);
			buf[3] = static_cast<uint8_t>(size & 0xFF);
		}

	MessagePointer msg_;
};

#endif /* PACKEDMESSAGE_H */

